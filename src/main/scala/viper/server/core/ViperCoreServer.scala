package viper.server.core

import java.util.NoSuchElementException

import akka.NotUsed
import akka.actor.ActorRef
import akka.stream.scaladsl.{Sink, Source}
import viper.server.ViperConfig
import viper.server.core.ViperBackendConfigs._
import viper.server.vsi.{Envelope, JobHandle, VerificationJobHandler, VerificationServerInterface}
import viper.silver.ast
import viper.silver.logger.ViperLogger
import viper.silver.reporter.Message

import scala.concurrent.Future
import scala.language.postfixOps
import scala.util.{Failure, Success}


class ViperCoreServer(private var _config: ViperConfig) extends VerificationServerInterface {

  // --- VCS : Configuration ---
  var isRunning: Boolean = true
  final def config: ViperConfig = _config

  protected var _logger: ViperLogger = _
  final def logger: ViperLogger = _logger


  /** Configures an instance of ViperCoreServer.
    *
    * This function should be called before any other.
    * */
  override def start(): Unit = {
    config.verify()

    _logger = ViperLogger("ViperServerLogger", config.getLogFileWithGuarantee, config.logLevel())
    println(s"Writing [level:${config.logLevel()}] logs into ${if (!config.logFile.isSupplied) "(default) " else ""}journal: ${logger.file.get}")

    NewViperCache.initialize(logger.get, config.backendSpecificCache())


    _termActor = system.actorOf(Terminator.props(), "terminator")
    println(s"ViperServer online in CoreServer mode")
  }

  /** Verifies a Viper AST using the specified backend.
    * */
  def verify(programID: String, backend_config: ViperBackendConfig, program: ast.Program): VerificationJobHandler = {
    if(!isRunning) {
      throw new IllegalStateException("Instance of ViperCoreServer already stopped")
    }
    val args: List[String] = backend_config match {
      case _ : SiliconConfig => "silicon" :: backend_config.partialCommandLine
      case _ : CarbonConfig => "carbon" :: backend_config.partialCommandLine
      case _ : CustomConfig => "DummyFrontend" :: backend_config.partialCommandLine
    }
    val task_backend = new VerificationWorker(_config, logger.get, args :+ programID, program)
    initializeVerificationProcess(task_backend)
  }

  /** Stops an instance of ViperCoreServer from running.
    *
    * As such it should be the ultimate method called. Calling any other function after 'stop()' will result in an
    * IllegalStateException.
    * */
  override def stop(): Unit = {
    if(!isRunning) {
      throw new IllegalStateException("Instance of ViperCoreServer already stopped")
    }
    isRunning = false

    println(s"Stopping ViperCoreServer")
    super.stop()
  }

  def flushCache(): Unit = {
    if(!isRunning) {
      throw new IllegalStateException("Instance of ViperCoreServer already stopped")
    }
    NewViperCache.resetCache()
    println(s"The cache has been flushed successfully.")
  }


  override def successHandleCallback(handle: JobHandle, clientActor: ActorRef): Unit = {
    val src_envelope: Source[Envelope, NotUsed] = Source.fromPublisher((handle.publisher))
    val src_msg: Source[Message, NotUsed] = src_envelope.map({
      case SilverEnvelope(msg) =>
        msg
    })
    src_msg.runWith(Sink.actorRef(clientActor, Success))
  }

  /** Stream all messages generated by the backend to some actor.

    * Deletes the jobhandle on completion.
    */
  def streamMessages(jid: Int, clientActor: ActorRef): Unit = {
    if(!isRunning) {
      throw new IllegalStateException("Instance of ViperCoreServer already stopped")
    }
    terminateVerificationProcess(jid, clientActor)
  }
}

