package viper.server.core

import akka.actor.{Actor, ActorSystem, Props}
import akka.pattern.ask
import akka.util.Timeout
import viper.server.vsi.JobID
import viper.silver.reporter.{EntityFailureMessage, Message}
import viper.silver.verifier.{AbstractError, VerificationResult, Failure => VerificationFailure, Success => VerificationSuccess}

import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future, Promise}
import scala.util.Success

object ViperCoreServerUtils {
  implicit private val executionContext = ExecutionContext.global

  private object SeqActor {
    case object Result
    def props(): Props = Props(new SeqActor())
  }

  class SeqActor() extends Actor {

    var messages: List[Message] = List()
    var messages_promise: Promise[List[Message]] = Promise[List[Message]]()

    override def receive: PartialFunction[Any, Unit] = {
      case m: Message =>
        messages = messages :+ m
      case SeqActor.Result =>
        messages_promise.future
        sender() ! messages_promise
      case e: Throwable =>
        //receiving an error means the promise can be finalized with failure.
        messages_promise failure e
      case Success => messages_promise success messages
    }
  }

  /** Get a Future containing all messages generated by the backend.
    *
    * This is a utility function and not part of ViperCoreServer. Therefore, an instance of ViperCoreServer as well as
    * an instance of an actor system must be provided.
    *
    * Deletes the jobhandle on completion.
    */
  def getMessagesFuture(core: ViperCoreServer, jid: JobID)(implicit actor_system: ActorSystem): Future[List[Message]] = {
    val actor = actor_system.actorOf(SeqActor.props())
    core.streamMessages(jid, actor)
    implicit val askTimeout: Timeout = Timeout(core.config.actorCommunicationTimeout() milliseconds)
    val answer: Future[Any] = actor ? SeqActor.Result
    val messages_future: Future[List[Message]] = answer.flatMap({
      case res: Future[List[Message]] => res
    })
    messages_future
  }

  /** Get a Future containing only verification results.
    *
    * This is a utility function and not part of ViperCoreServer. Therefore, an instance of ViperCoreServer as well as
    * an instance of an actor system must be provided.
    *
    * Deletes the jobhandle on completion.
    */
  def getResultsFuture(core: ViperCoreServer, jid: JobID)(implicit actor_system: ActorSystem): Future[VerificationResult] = {
    val messages_future = getMessagesFuture(core, jid)
    val result_future: Future[VerificationResult] = messages_future.map(msgs => {

      val abstract_errors: Seq[AbstractError] = msgs.foldLeft(Seq(): Seq[AbstractError]) {(errors, msg) =>
        msg match {
          case EntityFailureMessage(_, _, _, VerificationFailure(errs), _) => errs ++ errors
          case _ => errors
        }
      }
      abstract_errors match {
        case Seq() => VerificationSuccess
        case errors => VerificationFailure(errors)
      }
    })
    result_future
  }
}
